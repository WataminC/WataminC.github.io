### 1. 深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、实现机制）。
事务是由一系列访问和更新操作组成的程序执行单元。这些操作要么都做，要么都不做，是一个不可分割的整体

1. 原子性 (Atomicity)
   - 事务中包含的所有操作(特指修改操作)要么全部做，要么全不做
   - 原子性由恢复机制实现
2. 一致性(Consistency)
   - 独立执行一个事务（无其它事务同时并发执行）的结果必须保证数据一致性。即事务开始前，数据满足一致性要求；事务结束后，数据虽然变化了，但仍然满足一致性的要求。
   - 一致性要求是指应用的要求，应根据具体现实而定
   - 完整性机制实现
3. 隔离性 (Isolation)
   - 任何一对事务T1、T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1结束以后再开始执行 (T2对数据库的修改，T1要么全部看到，要么全部看不到)
   - 隔离性通过并发控制机制(第16章)实现
4. 持久性(Durability)
   - 任何事务一旦提交了，它对数据库的影响就必须是永久性的。无论发生任何故障，都不能取消或破坏这种影响
  - 持久性通过恢复机制(第17章)实现

### 2. 掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。
- 事务以Begin  transaction语句开始(SQL Server是Start Transaction)，以Commit  或Rollback 语句结束
- Commit 语句：提交事务。此时事务正常结束，事务所做的修改操作都必须永久地写入数据库
- Rollback语句：回滚事务。此时事务非正常结束，事务所做的修改操作都必须撤销(Undo，数据改回旧值)。数据库回退到事务开始前的状态，就好像事务从来没有发生过一样。

### 3. 熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。

- 丢失修改

并发调度两个事务T1、T2, T1与T2从数据库中读入同一数据后分别修改。假设T1先提交，而T2后提交.则T2提交的修改覆盖了T1提交的修改，导致T1的修改丢失

- 不可重复读

事务T1读取某些数据（记录）后，事务T2对这些数据（记录）做了某种修改操作, 当T1再次读取该数据（记录）时，得到的是与前一次不同的值


- 读“脏”数据

在事务T1两次读取之间，
- 另一事务T2更新了记录。则当T1第二次读取时，得到与前一次不同的记录值
- 另一事务T2删除了部分记录。则当T1第二次读取时，发现其中的某些记录神秘地消失了
- 另一事务T2插入了一些记录。则当T1第二次按相同条件读取时，发现地神秘地多了一些记录

后两种不可重复读有时也称为幻影现象

产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。

### 4. 并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。

### 5. 并发控制的任务

1. 保证事务的并发执行（调度）是（尽量）正确的，避免不一致问题的产生。常见的一种实现方法是封锁。
2. 保证事务的隔离性
3. 保证数据一致性

### 6. 封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。它们的相容关系？

事务T在对某个数据对象（关系、元组等）进行操作之前，先向系统发出请求，对其加锁。事务T对某个数据对象加锁后，其它事务就不能对这个数据对象进行某些相应操作，直到事务T释放它的锁为止

- X锁，又称写锁，或排它锁
  - 事务T 对数据对象A进行修改操作前，给A加上X锁。加上X锁后，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的X锁为止

- S锁，又称读锁，或共享锁
  - 事务T 对数据对象A进行读取操作前，给A加上S锁。加上S锁后，其它事务能再对A加S锁，但不能加X锁，直到T释放A上的S锁为止

X锁对所有的请求都不相容, S锁对本身相容

### 7. 有哪几种封锁协议？规则是什么？可分别解决哪些数据不一致性问题？

- 封锁协议
  - 事务对数据对象加锁时，还需要遵守某些规则，包括：何时加锁，何时释放。称这些规则为封锁协议(Locking Protocol)
- 三种封锁协议
  - 一级封锁协议
  - 二级封锁协议
  - 三级封锁协议

- 一级封锁协议
  - 若要修改数据R，事务T必须先对其加X锁(数据R最早的读写操作前)
  - X锁直到事务结束(commit或rollback后)才释放
  - 一级封锁协议可解决丢失修改的问题
    - 没有事务能够修改其它事务正在修改，还未提交的数据

- 二级封锁协议
  - 一级封锁协议＋
  - 若要读取数据R，事务T必须先对其加S锁(数据R最早的读操作前)
  - 在读完后，可以在任意时候释放S锁
  - 二级封锁协议可解决读脏数据的问题

- 三级封锁协议
    - 一级封锁协议＋
    - 若要修改数据R，事务T必须先对其加S锁(数据R最早的读操作前)
    - 直到事务结束后才释放S锁
    - 三级封锁协议可解决不可重复读的问题
        - 没有事务能够修改其它事务正在读取的数据

- 两段式封锁协议
    - 在对任何数据进行读写之前，事务首先要获得对该数据的封锁 ，释放封锁后不能再读、写该数据
    - 在释放第一个封锁之后，事务不再获得任何其它封锁，即事务分为两个阶段
      - 生长阶段：获得封锁
      - 收缩阶段：释放封锁
    - 首次释放掉一个封锁后，即由生长阶段转入收缩阶段

- 定理：若所有事务均遵从两段锁协议，则对这些事务的并行调度都是可串行化的
  - 反过来，在一个可串行化调度中，不一定所有事务都遵从两段锁协议
  - 因此，所有事务都遵从两段锁协议，是可串行化调度的充分而不是必要条件


### 8. 数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。
- 事务故障
  - 因某种原因，事务无法继续执行而失败。
    1. 事务内部执行语句产生的逻辑错误。例如：除零、运算溢出，余额不足。
    2. 事务外部条件造成的系统错误。例如：死锁造成事务无法获得执行。
  - 特征
    - 发生故障的事务异常结束。除此之外，系统和其它事务仍正常运行。
  - 恢复（修复故障，解决问题）
    - UNDO 故障事务 —— 找到事务的全部修改并撤消之(改成旧值)，纠正它修改已经写入磁盘的错误。

- 系统故障 (Soft Crash, 软故障)
  - 因某种错误，造成DBMS停止运行
    1. 硬件错误。例如CPU或内存故障等
    2. 软件错误。例如OS或者DBMS本身的异常。
    3. 其它，例如突然停电等。
  - 特征
    - 系统需要重新启动。结果缓冲中的数据丢失，但磁盘上的数据仍然完好。
  - 恢复
    - UNDO 未提交事务 —— 找到这些事务的全部修改并撤消之(改成旧值) ，纠正它们修改已写入磁盘的错误。
    - REDO 已提交事务 —— 找到这些事务的全部修改并重做之 (改成新值) ，纠正它们修改未写入磁盘的错误。

- 磁盘故障 (Hard Crash, 硬故障)
  - 因某种原因，磁盘上的数据部分或完全丢失。
    - 一般是相关的人为破坏或者硬件故障，例如：错误的格式化、磁盘坏道、机房失火等。
- 特征
  - 磁盘上的数据丢失。
- 恢复
  - 根据其它地点（磁盘、磁带）上的数据备份，重建数据库。

- 对未提交的事务，可能出现修改已写入磁盘的错误（需要UNDO）
- 对已提交的事务，可能出现修改未写入磁盘的错误（需要REDO）

- 恢复的基本原理：冗余
  - 任何数据被破坏或发生错误后，都可以通过存储在其它地点的冗余数据重建该数据。
- 要解决的关键问题
  1. 如何建立冗余数据
    - 数据转储
    - 登记日志文件
  2. 恢复策略（如何根据冗余数据，重建正确的数据）
     1. 事务故障的恢复
     2. 系统故障的恢复
     3. 磁盘故障的恢复

### 9. 静态备份 vs 动态备份（有否一致性；数据库是否可用，即是否允许用户运行事务来操作数据库）。完全备份 vs 增量备份（优缺点对比）。

- 数据转储

由DBA定期将数据库进行复制，得到后备副本并保存在另外的磁盘或磁带上的过程。

- 静态转储 vs 动态转储
  - 静态转储：在转储期间，系统中不能有事务运行。
    - 优点：实现简单，得到的数据库副本有一致性。
    - 缺点：转储时，数据库不可用。
  - 动态转储：在转储期间，允许事务存取或修改数据
    - 缺点：实现复杂，不能保证数据库副本有一致性。
    - 优点：转储时，数据库是可用的。

思考：为什么动态转储不能保证数据库副本的一致性?

- 海量(完全)转储 vs 增量转储
  - 海量转储：转储整个数据库。
  - 增量转储：转储（自上次转储以来）发生变化的那部分数据。



### 10. 日志文件：是用来记录事务对数据库进行修改操作的文件
登记日志文件（logging）
两种类型的日志文件
以记录为操作对象的日志文件
以数据块为操作对象的日志文件
登记到日志文件的内容
登记事务开始(Begin Transaction)的日志记录
登记事务结束(Commit 或 Rollback)的日志记录
登记事务中修改操作对象的日志记录(每次修改对应一条记录)


1.  日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记修改操作的日志记录时，修改前后的旧值与新值都要保存到日志记录中。
2.  什么是运行记录优先（先写日志）原则？
3.  熟记不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等...），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），每种故障类型的恢复过程，及由谁完成（系统自动 or 用户干预？）
4.  理解检查点机制的原理（写检查点做了什么工作？按相对检查点的位置，把事务分成几类，哪些需要REDO/UNDO，哪些不需要？）。检查点的作用（在恢复系统故障时，大大缩短需要扫描的日志文件的范围，这个范围是从哪里到哪里...）
5.  熟记引入检查点后，系统故障的恢复过程，并与之前没有检查点时的恢复过程作对比。

